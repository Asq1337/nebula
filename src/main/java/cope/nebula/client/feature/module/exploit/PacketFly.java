package cope.nebula.client.feature.module.exploit;

import cope.nebula.client.events.MotionEvent;
import cope.nebula.client.events.MotionUpdateEvent;
import cope.nebula.client.events.MotionUpdateEvent.Era;
import cope.nebula.client.events.PacketEvent;
import cope.nebula.client.events.PacketEvent.Direction;
import cope.nebula.client.feature.module.Module;
import cope.nebula.client.feature.module.ModuleCategory;
import cope.nebula.client.value.Value;
import cope.nebula.util.internal.math.Vec2d;
import cope.nebula.util.internal.timing.Stopwatch;
import cope.nebula.util.world.entity.player.MotionUtil;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer.PositionRotation;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.PlayerSPPushOutOfBlocksEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;

public class PacketFly extends Module {
    public PacketFly() {
        super("PacketFly", ModuleCategory.EXPLOIT, "Makes you fly with packets");
    }

    public static final Value<Mode> mode = new Value<>("Mode", Mode.MOTION);
    public static final Value<Bounds> bounds = new Value<>("Bounds", Bounds.NEGATIVE);
    public static final Value<Double> factor = new Value<>("Factor", 1.0, 0.1, 5.0);
    public static final Value<Boolean> antiKick = new Value<>("AntiKick", true);

    private final Map<Integer, Stopwatch> teleports = new ConcurrentHashMap<>();
    private int tpId = 0;

    @Override
    protected void onDeactivated() {
        teleports.clear();
        tpId = 0;

        mc.player.noClip = false;
    }

    @Override
    public void onTick() {
        teleports.forEach((tpId, timer) -> {
            if (timer.passedSeconds(10L)) {
                mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpId));
                teleports.remove(tpId);
            }
        });
    }

    @SubscribeEvent
    public void onMotion(MotionEvent event) {
        event.setX(mc.player.motionX);
        event.setY(mc.player.motionY);
        event.setZ(mc.player.motionZ);

        mc.player.noClip = true;
    }

    @SubscribeEvent
    public void onMotionUpdate(MotionUpdateEvent event) {
        if (event.getEra().equals(Era.PRE)) {
            double speed = factor.getValue() / 10.0;
            if (isInBlock()) {
                speed /= 2.5;
            }

            if (mc.gameSettings.keyBindJump.isPressed()) {
                mc.player.motionY = mc.player.ticksExisted % 6 == 0 ? speed : 0.02;
            } else if (mc.gameSettings.keyBindSneak.isPressed()) {
                mc.player.motionY = -speed;
            } else {
                mc.player.motionY = 0.0;
                if (!isInBlock() && antiKick.getValue() && !MotionUtil.isMoving()) {
                    mc.player.motionY = -0.02;
                }
            }

            if (MotionUtil.isMoving()) {
                Vec2d motion = MotionUtil.strafe(speed);

                if (mode.getValue().equals(Mode.FACTOR)) {
                    double factorX = motion.getX() / factor.getValue();
                    double factorZ = motion.getZ() / factor.getValue();

                    mc.player.motionX = motion.getX();
                    mc.player.motionZ = motion.getZ();

                    for (int i = 0; i < factor.getValue().intValue(); ++i) {
                        sendPackets(mc.player.getPositionVector().add(factorX * i, mc.player.motionY, factorZ * i), false);
                    }
                } else if (mode.getValue().equals(Mode.MOTION)) {
                    mc.player.motionX = motion.getX();
                    mc.player.motionZ = motion.getZ();
                }
            } else {
                mc.player.motionX = 0.0;
                mc.player.motionZ = 0.0;
            }

            sendPackets(mc.player.getPositionVector().add(mc.player.motionX, mc.player.motionY, mc.player.motionZ), true);
        }
    }

    @SubscribeEvent
    public void onPacket(PacketEvent event) {
        if (event.getDirection().equals(Direction.INCOMING) && event.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook packet = event.getPacket();

            tpId = packet.getTeleportId();
            teleports.put(packet.getTeleportId(), new Stopwatch().resetTime());
        }
    }

    @SubscribeEvent
    public void onPushOutOfBlocks(PlayerSPPushOutOfBlocksEvent event) {
        event.setCanceled(true);
    }

    private void sendPackets(Vec3d vec, boolean sendBounds) {
        sendPacket(vec);
        if (!bounds.getValue().equals(Bounds.NONE) && sendBounds) {
            sendPacket(getOutOfBoundsVec(vec));
        }
    }

    private void sendPacket(Vec3d vec) {
        float yaw = getNebula().getRotationManager().getYaw();
        float pitch = getNebula().getRotationManager().getPitch();

        mc.player.connection.sendPacket(new PositionRotation(vec.x, vec.y, vec.z, yaw, pitch, mc.player.onGround));
        mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpId++));

        teleports.put(tpId, new Stopwatch().resetTime());
    }

    private boolean isInBlock() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    private Vec3d getOutOfBoundsVec(Vec3d vec) {
        if (!bounds.getValue().equals(Bounds.NONE)) {
            switch (bounds.getValue()) {
                case NEGATIVE: {
                    vec = vec.add(0.0, -1377.0, 0.0);
                    break;
                }

                case POSITIVE: {
                    vec = vec.add(0.0, 1337.0, 0.0);
                    break;
                }

                case PRESERVE: {
                    vec = vec.add(1000.0, 0.0, 1000.0);
                    break;
                }

                case RANDOM: {
                    vec = vec.add(0.0, ThreadLocalRandom.current().nextDouble(-1337.0, 1337.0), 0.0);
                    break;
                }
            }
        }

        return vec;
    }

    public enum Mode {
        FACTOR, MOTION
    }

    public enum Bounds {
        NEGATIVE, POSITIVE, PRESERVE, RANDOM, NONE
    }
}
