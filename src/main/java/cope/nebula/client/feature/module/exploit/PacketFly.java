package cope.nebula.client.feature.module.exploit;

import cope.nebula.client.events.MotionEvent;
import cope.nebula.client.events.MotionUpdateEvent;
import cope.nebula.client.events.MotionUpdateEvent.Era;
import cope.nebula.client.events.PacketEvent;
import cope.nebula.client.feature.module.Module;
import cope.nebula.client.feature.module.ModuleCategory;
import cope.nebula.client.value.Value;
import cope.nebula.util.internal.math.Vec2d;
import cope.nebula.util.internal.timing.Stopwatch;
import cope.nebula.util.internal.timing.TimeFormat;
import cope.nebula.util.world.entity.player.MotionUtil;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer.PositionRotation;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class PacketFly extends Module {
    public PacketFly() {
        super("PacketFly", ModuleCategory.EXPLOIT, "Makes you fly with packets");
    }

    public static final Value<Mode> mode = new Value<>("Mode", Mode.SETBACK);
    public static final Value<Double> factor = new Value<>("Factor", 0.5, 0.1, 5.0);

    private final Map<Integer, Stopwatch> teleports = new ConcurrentHashMap<>();
    private int tpId = 0;

    @Override
    protected void onDeactivated() {
        teleports.clear();
        tpId = 0;

        mc.player.noClip = false;
    }

    @Override
    public void onTick() {
        teleports.forEach((tpId, timer) -> {
            if (timer.hasElapsed(10L, TimeFormat.SECONDS)) {
                mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpId));
                teleports.remove(tpId);
            }
        });
    }

    @SubscribeEvent
    public void onMotion(MotionEvent event) {
        event.setX(mc.player.motionX);
        event.setY(mc.player.motionY);
        event.setZ(mc.player.motionZ);

        mc.player.noClip = true;
    }

    @SubscribeEvent
    public void onMotionUpdate(MotionUpdateEvent event) {
        if (event.getEra().equals(Era.PRE)) {
            if (mc.gameSettings.keyBindJump.isPressed()) {
                mc.player.motionY = mc.player.ticksExisted % 6 == 0 ? 0.01 : 0.02;
            } else if (mc.gameSettings.keyBindSneak.isPressed()) {
                mc.player.motionY = -0.02;
            } else {
                mc.player.motionY = 0.0;
                if (!isInBlock()) {
                    mc.player.motionY = mc.player.ticksExisted % 2 == 0 ? -0.02 : -0.001;
                }
            }

            if (MotionUtil.isMoving()) {
                double speed = factor.getValue();
                if (isInBlock()) {
                    speed /= 2.5;
                }

                Vec2d motion = MotionUtil.strafe(speed);

                if (mode.getValue().equals(Mode.FACTOR)) {
                    double factorX = motion.getX() / factor.getValue();
                    double factorZ = motion.getZ() / factor.getValue();

                    mc.player.motionX = motion.getX();
                    mc.player.motionZ = motion.getZ();

                    for (int i = 0; i < factor.getValue().intValue(); ++i) {
                        sendPacket(mc.player.posX + (factorX * i), mc.player.posY + mc.player.motionY, mc.player.posZ + (factorZ * i), false);
                    }

                    sendPacket(mc.player.posX + mc.player.motionX, mc.player.posY + mc.player.motionY, mc.player.posZ + mc.player.motionZ, true);
                } else if (mode.getValue().equals(Mode.SETBACK)) {
                    mc.player.motionX = motion.getX();
                    mc.player.motionZ = motion.getZ();

                    sendPacket(mc.player.posX + mc.player.motionX, mc.player.posY + mc.player.motionY, mc.player.posZ + mc.player.motionZ, true);
                }
            } else {
                mc.player.motionX = 0.0;
                mc.player.motionZ = 0.0;
            }
        }
    }

    @SubscribeEvent
    public void onPacket(PacketEvent event) {
        switch (event.getDirection()) {
            case INCOMING: {
                if (event.getPacket() instanceof SPacketPlayerPosLook) {
                    SPacketPlayerPosLook packet = event.getPacket();

                    tpId = packet.getTeleportId();
                    teleports.put(tpId, new Stopwatch().resetTime());
                }
                break;
            }
        }
    }

    private void sendPacket(double x, double y, double z, boolean bounds) {
        mc.player.connection.sendPacket(new CPacketConfirmTeleport(tpId++));
        mc.player.connection.sendPacket(new PositionRotation(x, y, z, mc.player.rotationYaw, mc.player.rotationPitch, false));

        if (bounds) {
            mc.player.connection.sendPacket(new PositionRotation(x, y - 1337.0, z, mc.player.rotationYaw, mc.player.rotationPitch, false));
        }

        teleports.put(tpId, new Stopwatch().resetTime());
    }

    private boolean isInBlock() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    public enum Mode {
        FACTOR, SETBACK
    }
}
